<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>bingocpp: /users0/gbomarit/Projects/Genetic_Programming/bingocpp/src/acyclic_graph.cc File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">bingocpp
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">acyclic_graph.cc File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;math.h&gt;</code><br />
<code>#include &lt;Eigen/Dense&gt;</code><br />
<code>#include &lt;set&gt;</code><br />
<code>#include &lt;map&gt;</code><br />
<code>#include &lt;iostream&gt;</code><br />
<code>#include &quot;BingoCpp/acyclic_graph.h&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a03419f0d5d62aada3d13e18baa9e6fa3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="acyclic__graph_8cc.html#a03419f0d5d62aada3d13e18baa9e6fa3">ForwardSingleCommand</a> (const SingleCommand &amp;command, const Eigen::ArrayXXd &amp;x, const std::vector&lt; double &gt; &amp;constants, std::vector&lt; Eigen::ArrayXXd &gt; &amp;buffer, std::size_t result_location)</td></tr>
<tr class="memdesc:a03419f0d5d62aada3d13e18baa9e6fa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates single stack command given x and constants.  <a href="#a03419f0d5d62aada3d13e18baa9e6fa3">More...</a><br /></td></tr>
<tr class="separator:a03419f0d5d62aada3d13e18baa9e6fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb0e023a9d5b7e747620678d71a9e7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="acyclic__graph_8cc.html#a7fb0e023a9d5b7e747620678d71a9e7f">ReverseSingleCommand</a> (const CommandStack &amp;stack, const int command_index, const std::vector&lt; Eigen::ArrayXXd &gt; &amp;forward_buffer, std::vector&lt; Eigen::ArrayXXd &gt; &amp;reverse_buffer, const std::set&lt; int &gt; &amp;dependencies)</td></tr>
<tr class="memdesc:a7fb0e023a9d5b7e747620678d71a9e7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes reverse autodiff partial of a stack command.  <a href="#a7fb0e023a9d5b7e747620678d71a9e7f">More...</a><br /></td></tr>
<tr class="separator:a7fb0e023a9d5b7e747620678d71a9e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae17cee06461ea8390a2dfaf6894a3d26"><td class="memItemLeft" align="right" valign="top">Eigen::ArrayXXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="acyclic__graph_8cc.html#ae17cee06461ea8390a2dfaf6894a3d26">Evaluate</a> (const CommandStack &amp;stack, const Eigen::ArrayXXd &amp;x, const std::vector&lt; double &gt; &amp;constants)</td></tr>
<tr class="memdesc:ae17cee06461ea8390a2dfaf6894a3d26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates a stack at the given x using the given constants.  <a href="#ae17cee06461ea8390a2dfaf6894a3d26">More...</a><br /></td></tr>
<tr class="separator:ae17cee06461ea8390a2dfaf6894a3d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac7107253791367d79a49fd5c001cdde"><td class="memItemLeft" align="right" valign="top">Eigen::ArrayXXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="acyclic__graph_8cc.html#aac7107253791367d79a49fd5c001cdde">SimplifyAndEvaluate</a> (const CommandStack &amp;stack, const Eigen::ArrayXXd &amp;x, const std::vector&lt; double &gt; &amp;constants)</td></tr>
<tr class="memdesc:aac7107253791367d79a49fd5c001cdde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates a stack, but only the commands that are utilized.  <a href="#aac7107253791367d79a49fd5c001cdde">More...</a><br /></td></tr>
<tr class="separator:aac7107253791367d79a49fd5c001cdde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecd7bc815523400785809ded3d04ab46"><td class="memItemLeft" align="right" valign="top">Eigen::ArrayXXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="acyclic__graph_8cc.html#aecd7bc815523400785809ded3d04ab46">EvaluateWithMask</a> (const CommandStack &amp;stack, const Eigen::ArrayXXd &amp;x, const std::vector&lt; double &gt; &amp;constants, const std::vector&lt; bool &gt; &amp;mask)</td></tr>
<tr class="memdesc:aecd7bc815523400785809ded3d04ab46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates a stack at the given x using the given constants.  <a href="#aecd7bc815523400785809ded3d04ab46">More...</a><br /></td></tr>
<tr class="separator:aecd7bc815523400785809ded3d04ab46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac989d06e2774841fa11f9d89a394f6"><td class="memItemLeft" align="right" valign="top">std::pair&lt; Eigen::ArrayXXd, Eigen::ArrayXXd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="acyclic__graph_8cc.html#adac989d06e2774841fa11f9d89a394f6">EvaluateWithDerivative</a> (const CommandStack &amp;stack, const Eigen::ArrayXXd &amp;x, const std::vector&lt; double &gt; &amp;constants)</td></tr>
<tr class="memdesc:adac989d06e2774841fa11f9d89a394f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates a stack and its derivative with the given x and constants.  <a href="#adac989d06e2774841fa11f9d89a394f6">More...</a><br /></td></tr>
<tr class="separator:adac989d06e2774841fa11f9d89a394f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affb89b40cf961aca71fe4a627dee2bde"><td class="memItemLeft" align="right" valign="top">std::pair&lt; Eigen::ArrayXXd, Eigen::ArrayXXd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="acyclic__graph_8cc.html#affb89b40cf961aca71fe4a627dee2bde">SimplifyAndEvaluateWithDerivative</a> (const CommandStack &amp;stack, const Eigen::ArrayXXd &amp;x, const std::vector&lt; double &gt; &amp;constants)</td></tr>
<tr class="memdesc:affb89b40cf961aca71fe4a627dee2bde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates a stack and its derivative, but only the utilized commands.  <a href="#affb89b40cf961aca71fe4a627dee2bde">More...</a><br /></td></tr>
<tr class="separator:affb89b40cf961aca71fe4a627dee2bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76fca6774cc394fbc5a0140edd7679c1"><td class="memItemLeft" align="right" valign="top">std::pair&lt; Eigen::ArrayXXd, Eigen::ArrayXXd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="acyclic__graph_8cc.html#a76fca6774cc394fbc5a0140edd7679c1">EvaluateWithDerivativeAndMask</a> (const CommandStack &amp;stack, const Eigen::ArrayXXd &amp;x, const std::vector&lt; double &gt; &amp;constants, const std::vector&lt; bool &gt; &amp;mask)</td></tr>
<tr class="memdesc:a76fca6774cc394fbc5a0140edd7679c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates a stack and its derivative with the given x and constants.  <a href="#a76fca6774cc394fbc5a0140edd7679c1">More...</a><br /></td></tr>
<tr class="separator:a76fca6774cc394fbc5a0140edd7679c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29009492a9bd2585e5821c0e49f2fdcf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="acyclic__graph_8cc.html#a29009492a9bd2585e5821c0e49f2fdcf">PrintStack</a> (const CommandStack &amp;stack)</td></tr>
<tr class="memdesc:a29009492a9bd2585e5821c0e49f2fdcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a stack to std::cout.  <a href="#a29009492a9bd2585e5821c0e49f2fdcf">More...</a><br /></td></tr>
<tr class="separator:a29009492a9bd2585e5821c0e49f2fdcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67419b2cbf948ffd22f6827f9d5f7a4f"><td class="memItemLeft" align="right" valign="top">CommandStack&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="acyclic__graph_8cc.html#a67419b2cbf948ffd22f6827f9d5f7a4f">SimplifyStack</a> (const CommandStack &amp;stack)</td></tr>
<tr class="memdesc:a67419b2cbf948ffd22f6827f9d5f7a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplifies a stack.  <a href="#a67419b2cbf948ffd22f6827f9d5f7a4f">More...</a><br /></td></tr>
<tr class="separator:a67419b2cbf948ffd22f6827f9d5f7a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b6eb9d84174a7dd78014409a50dfc7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="acyclic__graph_8cc.html#a04b6eb9d84174a7dd78014409a50dfc7">FindUsedCommands</a> (const CommandStack &amp;stack)</td></tr>
<tr class="memdesc:a04b6eb9d84174a7dd78014409a50dfc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds which commands are utilized in a stack.  <a href="#a04b6eb9d84174a7dd78014409a50dfc7">More...</a><br /></td></tr>
<tr class="separator:a04b6eb9d84174a7dd78014409a50dfc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a50aba3b3eb74ad91a996159d965fdf31"><td class="memItemLeft" align="right" valign="top">std::map&lt; int, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>OperatorString</b></td></tr>
<tr class="separator:a50aba3b3eb74ad91a996159d965fdf31"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>Geoffrey F. Bomarito </dd></dl>
<dl class="section date"><dt>Date</dt><dd></dd></dl>
<p>This file contains the functions associated with an acyclic graph representation of a symbolic equation. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ae17cee06461ea8390a2dfaf6894a3d26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::ArrayXXd Evaluate </td>
          <td>(</td>
          <td class="paramtype">const CommandStack &amp;&#160;</td>
          <td class="paramname"><em>stack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::ArrayXXd &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>constants</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates a stack at the given x using the given constants. </p>
<p>An acyclic graph is given in stack form. The stack is evaluated command by command putting the result of each command into a local buffer. References can be made in the stack to columns of the x input as well as constants; both are referenced by index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stack</td><td>Description of an acyclic graph in stack format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The input variables to the acyclic graph. (Eigen::ArrayXXd) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constants</td><td>Vector of the constants used in the stack.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the last command in the stack. (Eigen::ArrayXXd) </dd></dl>

</div>
</div>
<a class="anchor" id="adac989d06e2774841fa11f9d89a394f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;Eigen::ArrayXXd, Eigen::ArrayXXd&gt; EvaluateWithDerivative </td>
          <td>(</td>
          <td class="paramtype">const CommandStack &amp;&#160;</td>
          <td class="paramname"><em>stack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::ArrayXXd &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>constants</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates a stack and its derivative with the given x and constants. </p>
<p>An acyclic graph is given in stack form. The stack is evaluated command by command putting the result of each command into a local buffer. References can be made in the satck to columns of the x input as well as constants; both are referenced by index. The stack is then processed in reverse to calculate the gradient of the stack with respect to x. This reverse processing is standard reverse auto-differentiation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stack</td><td>Description of an acyclic graph in stack format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The input variables to the acyclic graph. (Eigen::ArrayXXd) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constants</td><td>Vector of the constants used in the stack.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the last command in the stack and the gradient. (std::pair&lt;Eigen::ArrayXXd, Eigen::ArrayXXd&gt;) </dd></dl>

</div>
</div>
<a class="anchor" id="a76fca6774cc394fbc5a0140edd7679c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;Eigen::ArrayXXd, Eigen::ArrayXXd&gt; EvaluateWithDerivativeAndMask </td>
          <td>(</td>
          <td class="paramtype">const CommandStack &amp;&#160;</td>
          <td class="paramname"><em>stack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::ArrayXXd &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>constants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates a stack and its derivative with the given x and constants. </p>
<p>An acyclic graph is given in stack form. The stack is evaluated command by command (but only the ones with a true value of the mask) putting the result of each command into a local buffer. References can be made in the satck to columns of the x input as well as constants; both are referenced by index. The stack is then processed in reverse (again considering only the ones with a true value of the mask) to calculate the gradient of the stack with respect to x. This reverse processing is standard reverse auto-differentiation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stack</td><td>Description of an acyclic graph in stack format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The input variables to the acyclic graph. (Eigen::ArrayXXd) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constants</td><td>Vector of the constants used in the stack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>Vector of booleans detailing which commands are included.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the last command in the stack and the gradient. (std::pair&lt;Eigen::ArrayXXd, Eigen::ArrayXXd&gt;) </dd></dl>

</div>
</div>
<a class="anchor" id="aecd7bc815523400785809ded3d04ab46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::ArrayXXd EvaluateWithMask </td>
          <td>(</td>
          <td class="paramtype">const CommandStack &amp;&#160;</td>
          <td class="paramname"><em>stack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::ArrayXXd &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>constants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates a stack at the given x using the given constants. </p>
<p>An acyclic graph is given in stack form. The stack is evaluated command by command (but only the ones with a true value of the mask) putting the result of each command into a local buffer. References can be made in the satck to columns of the x input as well as constants; both are referenced by index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stack</td><td>Description of an acyclic graph in stack format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The input variables to the acyclic graph. (Eigen::ArrayXXd) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constants</td><td>Vector of the constants used in the stack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>Vector of booleans detailing which commands are included.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the last command in the stack. (Eigen::ArrayXXd) </dd></dl>

</div>
</div>
<a class="anchor" id="a04b6eb9d84174a7dd78014409a50dfc7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;bool&gt; FindUsedCommands </td>
          <td>(</td>
          <td class="paramtype">const CommandStack &amp;&#160;</td>
          <td class="paramname"><em>stack</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds which commands are utilized in a stack. </p>
<p>An acyclic graph is given in stack form. The stack is processed in reverse to find which commands the last command depends.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stack</td><td>Description of an acyclic graph in stack format.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector describing which commands in the stack are used. </dd></dl>

</div>
</div>
<a class="anchor" id="a03419f0d5d62aada3d13e18baa9e6fa3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ForwardSingleCommand </td>
          <td>(</td>
          <td class="paramtype">const SingleCommand &amp;&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::ArrayXXd &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>constants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Eigen::ArrayXXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>result_location</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates single stack command given x and constants. </p>
<p>The stack command is evaluated using a the hard coded directives for the operators. The result of each command is saved into a local buffer. References can be made in the command to previous buffer values, columns of the x input, and constants; all are referenced by index.</p>
<dl class="section note"><dt>Note</dt><dd>Addition of new operators must edit this segment.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">command</td><td>Description of a command. std::pair&lt;operator, params&gt;. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The input variables to the acyclic graph. (Eigen::ArrayXXd) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constants</td><td>Vector of the constants used in the stack. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a29009492a9bd2585e5821c0e49f2fdcf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PrintStack </td>
          <td>(</td>
          <td class="paramtype">const CommandStack &amp;&#160;</td>
          <td class="paramname"><em>stack</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints a stack to std::cout. </p>
<p>An acyclic graph is given in stack form. The stack is printed to std::cout command by command in the following format: (stack_location) = operation : (parameters)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stack</td><td>Description of an acyclic graph in stack format. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7fb0e023a9d5b7e747620678d71a9e7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ReverseSingleCommand </td>
          <td>(</td>
          <td class="paramtype">const CommandStack &amp;&#160;</td>
          <td class="paramname"><em>stack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>command_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::ArrayXXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>forward_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Eigen::ArrayXXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>reverse_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>dependencies</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes reverse autodiff partial of a stack command. </p>
<p>The partial derivative of the result with respect to the command at the specified location in the stack is evaluated. This requires the addition of all the dependencies of the command using the chain rule. References can be made in to the forward buffer and later reverse buffer values; all are referenced by index.</p>
<dl class="section note"><dt>Note</dt><dd>Addition of new operators must edit this segment.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stack</td><td>Description of an acyclic graph in stack format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">command_index</td><td>Index of command in the stack; also the location of the result to be placed in the reverse buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">forward_buffer</td><td>Vector of Eigen arrays for the forward buffer. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aac7107253791367d79a49fd5c001cdde"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::ArrayXXd SimplifyAndEvaluate </td>
          <td>(</td>
          <td class="paramtype">const CommandStack &amp;&#160;</td>
          <td class="paramname"><em>stack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::ArrayXXd &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>constants</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates a stack, but only the commands that are utilized. </p>
<p>An acyclic graph is given in stack form. The stack is evaluated, but only the commands which are utilized by the final result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stack</td><td>Description of an acyclic graph in stack format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The input variables to the acyclic graph. (Eigen::ArrayXXd) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constants</td><td>Vector of the constants used in the stack.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the last command in the stack. (Eigen::ArrayXXd) </dd></dl>

</div>
</div>
<a class="anchor" id="affb89b40cf961aca71fe4a627dee2bde"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;Eigen::ArrayXXd, Eigen::ArrayXXd&gt; SimplifyAndEvaluateWithDerivative </td>
          <td>(</td>
          <td class="paramtype">const CommandStack &amp;&#160;</td>
          <td class="paramname"><em>stack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::ArrayXXd &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>constants</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates a stack and its derivative, but only the utilized commands. </p>
<p>An acyclic graph is given in stack form. The stack is evaluated with its derivative, but only the commands which are utilized by the final result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stack</td><td>Description of an acyclic graph in stack format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The input variables to the acyclic graph. (Eigen::ArrayXXd) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constants</td><td>Vector of the constants used in the stack.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the last command in the stack and the gradient. (std::pair&lt;Eigen::ArrayXXd, Eigen::ArrayXXd&gt;) </dd></dl>

</div>
</div>
<a class="anchor" id="a67419b2cbf948ffd22f6827f9d5f7a4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CommandStack SimplifyStack </td>
          <td>(</td>
          <td class="paramtype">const CommandStack &amp;&#160;</td>
          <td class="paramname"><em>stack</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplifies a stack. </p>
<p>An acyclic graph is given in stack form. The stack is first simplified to consist only of the commands used by the last command.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stack</td><td>Description of an acyclic graph in stack format.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Simplified stack. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a50aba3b3eb74ad91a996159d965fdf31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;int, std::string&gt; OperatorString</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div><div class="line">  {0, <span class="stringliteral">&quot;X&quot;</span>},</div><div class="line">  {1, <span class="stringliteral">&quot;C&quot;</span>},</div><div class="line">  {2, <span class="stringliteral">&quot;+&quot;</span>},</div><div class="line">  {3, <span class="stringliteral">&quot;-&quot;</span>},</div><div class="line">  {4, <span class="stringliteral">&quot;*&quot;</span>},</div><div class="line">  {5, <span class="stringliteral">&quot;/&quot;</span>}</div><div class="line">}</div></div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
